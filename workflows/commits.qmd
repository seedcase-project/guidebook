# Commits

This guide covers how we in the Seedcase Project commit changes to our
repositories. We follow a set of guidelines to ensure that our commit
history is clear and consistent, which allows us to automatically
generate changelogs and version updates.

Below, we'll go through when and what to commit, the Conventional
Commits specification, and how to apply it to both code and non-code
projects.

## When and what to commit

In the Seedcase Project, we follow a few guidelines for when and what we
commit. We aim to:

-   Make atomic commits: Each commit should represent a single logical
    change.
-   Commit often: Make commits frequently to capture progress and
    changes.
-   Write short and meaningful messages: Write clear and descriptive
    commit messages that explain the change following a consistent
    format. We follow the [Conventional Commits](#conventional-commits)
    specification for this.

## Conventional commits {#conventional-commits}

[Conventional Commits](https://www.conventionalcommits.org/en/v1.0.0/)
is a specification for writing commit messages that makes it easier to
understand the history of a project and automate versioning and
changelogs. To see why we follow this specification (with optional
emojis following the [Gitmoji](https://gitmoji.dev/) specification),
check out the [decision
post](https://decisions.seedcase-project.org/why-conventional-commits/)
on our decisions website.

The Conventional Commits specification generally follows the format:

``` bash
<type>[optional scope]: <description>

[optional body]

[optional footer(s)]
```

For example:

``` bash
fix: prevent overwriting existing raw files
```

Where:

-   `<type>` is the type of change.
-   `[optional scope]` indicates the area of the codebase affected by
    the change.
-   `<description>` is a brief summary of the change.
-   `[optional body]` provides additional context or details about the
    change.
-   `[optional footer(s)]` includes breaking changes or references to
    issues/tasks.

::: callout-tip
In the Seedcase Project, we use the VS Code extension [Conventional
Commits](https://marketplace.visualstudio.com/items?itemName=vivaxy.vscode-conventional-commits)
to help us write conventional commit messages. It allows us to add
emojis following the [Gitmoji](https://gitmoji.dev/) specification to
make the messages more expressive and visually appealing.

So, if you use VS Code, we recommend installing this extension to ease
the process of writing conventional commit messages.
:::

### Required: type and description

The `<type>` in Conventional Commits is inspired by [Angular's commit
message
conventions](https://github.com/angular/angular/blob/22b96b9/CONTRIBUTING.md#-commit-message-guidelines)
and is used to categorise the changes made in the commit:

-   `build`: Changes that affect the build system or external
    dependencies.
-   `ci`: Changes to our CI configuration files and scripts.
-   `docs`: Documentation only changes.
-   `feat`: A new feature.
-   `fix`: A bug fix.
-   `perf`: A code change that improves performance.
-   `refactor`: A code change that neither fixes a bug nor adds a
    feature.
-   `style`: Changes that do not affect the meaning of the code
    (white-space, formatting, missing semi-colons, etc).
-   `test`: Adding missing tests or correcting existing tests.
-   `revert`: Reverts a previous commit.
-   `chore`: Other changes that don't modify src or test files.

The `<description>` is a short summary of the change. It should be
descriptive enough to understand the change without needing to look at
actual changes. It is written in the imperative, present tense
(i.e., "change" not "changed" nor "changes"), is not capitalized, and is
without a period at the end.

### Optional: scope, body, and footer(s)

In the Seedcase Project, we tend not to use `[optional scope]` that
often. We mostly use it in automatic commits that are generated by tools like
[Dependabot](https://github.com/dependabot).

Whenever we want to expand on the `<description>`, we add an
`[optional body]` that provides more context or details about the
change. This can include the motivation for the change, how it was
implemented, or any other relevant information that didn't fit in the
description.

The `[optional footer(s)]` can be used for various purposes, such as
indicating breaking changes or referencing issues. We rarely use them,
but if we want to indicate a breaking change, we will add a footer in
the format `BREAKING CHANGE: <description>`. Following the Conventional
Commits specification, whenever adding a breaking change, we will also
add a `!` after the `<type>` in the commit message. For example:

``` md
feat!: new feature that breaks existing functionality

BREAKING CHANGE: This feature changes the way the existing functionality
works, so it is not backward compatible.
```

## Conventional commits for non-code projects

The conventional commit specification was created for software or
code-related projects, but we also use it for documentation, workshops,
and other non-code projects. In these cases, we adapt the use of
`<type>` so we can still use it for creating meaningful changelogs and
versioning.

Some of the types are the same in documentation and other non-code
projects as in software projects. This includes `build`, `ci`, `style`,
`chore`, and `revert`. The types `test` and `perf` are not relevant in
documentation or non-code projects, so we don't use them there. The same
goes for the `docs` type: Since most changes in documentation or other
non-code projects are related to documentation, we don't use the `docs`
type. Instead, we use other types that are more descriptive of the
change being made.

For non-code projects, we use the following commit types differently
than in software projects:

-   `feat`: Changes that add new content.
-   `refactor`: Changes that modify or revise existing content, where
    the meaning or intent stays the same. This is used in editing or
    proofreading phases or tasks.
-   `fix`: Changes that fix typos, grammatical errors, incomplete
    sentences, or other similar writing mix-ups/situations where the
    text doesn't align with our original intent.

Each time we finish running a workshop, weâ€™ll mark it with a
`BREAKING CHANGE: <description>` footer. This breaking change commit
will be made *soon after* the workshop has been run to include all
changes made right before and during the workshop. By including this
footer, we clearly indicate that this is a new version of the workshop
related to that specific iteration of it. This helps us track workshop
versions and the updates made to each one. Following the Conventional
Commits specification, whenever we add a breaking change, we will also
add a `!` after the `<type>` in the commit message to indicate that it
is a breaking change.

As for emojis, we generally use them in the same way as in software
projects. The only emoji exception is the `:memo:` (:memo:) emoji that
is used for documentation-related commits. In the same way as the `docs`
type, it is redundant when almost all changes are related to
documentation. Instead, we use other emojis that are more descriptive of
the change being made or omit the emoji altogether.
